<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy"
      content="default-src 'none'; script-src 'nonce-{{nonce}}'; style-src 'unsafe-inline';">
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; background: var(--vscode-editor-background); }
  #board { position: fixed; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; touch-action: none; }
  #toolbar {
    position: fixed; top: 8px; left: 8px; right: 8px; z-index: 10;
    display: flex; gap: 4px; align-items: center;
    overflow-x: auto; flex-wrap: nowrap;
    scrollbar-width: thin;
    scrollbar-color: var(--vscode-scrollbarSlider-background, rgba(100,100,100,0.4)) transparent;
  }
  #toolbar::-webkit-scrollbar { height: 4px; }
  #toolbar::-webkit-scrollbar-track { background: transparent; }
  #toolbar::-webkit-scrollbar-thumb { background: var(--vscode-scrollbarSlider-background, rgba(100,100,100,0.4)); border-radius: 2px; }
  #toolbar button, #toolbar .tool-btn {
    padding: 4px 8px; cursor: pointer; flex-shrink: 0;
    background: var(--vscode-button-secondaryBackground); color: var(--vscode-button-secondaryForeground);
    border: none; border-radius: 3px; display: flex; align-items: center; justify-content: center;
    min-width: 28px; height: 28px;
  }
  #toolbar button:hover, #toolbar .tool-btn:hover { background: var(--vscode-button-hoverBackground); color: var(--vscode-button-foreground); }
  #toolbar button:disabled { opacity: 0.35; cursor: not-allowed; pointer-events: none; }
  #board.panning { cursor: grab; }
  #board.panning-active { cursor: grabbing; }
  #zoomLevelBtn { font-size: 11px; min-width: 40px; font-family: monospace; }
  #toolbar .tool-btn.active { background: var(--vscode-button-background); color: var(--vscode-button-foreground); outline: 1px solid var(--vscode-focusBorder); }
  #toolbar .tool-btn svg { width: 16px; height: 16px; }
  .separator { flex-shrink: 0; width: 1px; height: 20px; background: var(--vscode-panel-border); margin: 0 2px; }
  #colorPicker { flex-shrink: 0; width: 28px; height: 28px; cursor: pointer; border: none; padding: 0; border-radius: 3px; }
  #widthSlider { flex-shrink: 0; width: 50px; height: 20px; cursor: pointer; }
  #textInput {
    position: fixed; z-index: 20; display: none;
    background: var(--vscode-input-background); color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-focusBorder); border-radius: 3px;
    padding: 2px 4px; font: 16px sans-serif; outline: none; min-width: 80px;
  }
</style>
</head>
<body>
<div id="toolbar">
  <button class="tool-btn active" data-tool="select" title="Select (V)">
    <svg viewBox="0 0 16 16" fill="currentColor"><path d="M3 1l10 7-4.5 1L6 14z"/></svg>
  </button>
  <button class="tool-btn" data-tool="pen" title="Pen (P)">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><path d="M2 14c2-4 4-6 6-8s4-3 6-4"/></svg>
  </button>
  <button class="tool-btn" data-tool="rect" title="Rectangle (R)">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="3" width="12" height="10" rx="1"/></svg>
  </button>
  <button class="tool-btn" data-tool="ellipse" title="Circle / Ellipse (C)">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="8" cy="8" rx="6" ry="5"/></svg>
  </button>
  <button class="tool-btn" data-tool="line" title="Line (L)">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><line x1="2" y1="14" x2="14" y2="2"/></svg>
  </button>
  <button class="tool-btn" data-tool="arrow" title="Arrow (A)">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="2" y1="14" x2="13" y2="3"/><polyline points="7,3 13,3 13,9"/></svg>
  </button>
  <button class="tool-btn" data-tool="text" title="Text (T)">
    <svg viewBox="0 0 16 16" fill="currentColor"><text x="3" y="13" font-size="13" font-weight="bold" font-family="sans-serif">T</text></svg>
  </button>

  <span class="separator"></span>

  <input type="color" id="colorPicker" value="#ffffff" title="Color" />
  <input type="range" id="widthSlider" min="1" max="10" value="2" title="Stroke width" />

  <span class="separator"></span>

  <button id="undoBtn" disabled title="Undo (Ctrl+Z)">
    <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="currentColor"><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"/></svg>
  </button>
  <button id="redoBtn" disabled title="Redo (Ctrl+Y)">
    <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="currentColor"><path d="M396-200q-97 0-166.5-63T160-420q0-94 69.5-157T396-640h252L544-744l56-56 200 200-200 200-56-56 104-104H396q-63 0-109.5 40T240-420q0 60 46.5 100T396-280h284v80H396Z"/></svg>
  </button>

  <span class="separator"></span>

  <button id="deleteBtn" title="Delete selected (Del)"><svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="currentColor"><path d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z"/></svg></button>
  <button id="clearBtn">Clear</button>

  <span class="separator"></span>

  <button id="saveBtn" title="Save as PNG (Ctrl+S)">
    <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M8 2v8M5 7l3 3 3-3"/>
      <path d="M2 12v1a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-1"/>
    </svg>
  </button>

  <span class="separator"></span>

  <button id="zoomOutBtn" title="Zoom out (scroll wheel)">−</button>
  <button id="zoomLevelBtn" title="Reset view to 100% (Space+drag or middle-mouse to pan)">100%</button>
  <button id="zoomInBtn" title="Zoom in (scroll wheel)">+</button>
</div>
<input type="text" id="textInput" />
<canvas id="board"></canvas>
<script nonce="{{nonce}}">
const vscode = acquireVsCodeApi();
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const colorPicker = document.getElementById("colorPicker");
const widthSlider = document.getElementById("widthSlider");
const zoomLevelBtn = document.getElementById("zoomLevelBtn");

// --- State ---
const entities = new Map();
let currentTool = "select";
let currentColor = "#ffffff";
let currentWidth = 2;

// Drawing state
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let currentPoints = [];
let previewEntity = null;

// Selection state
let selectedIds = new Set(); // multi-selection
let dragMode = null; // null | "move" | "resize-nw" | "resize-ne" | "resize-sw" | "resize-se" | "rubber-band"
let dragStartPositions = null; // Map<id, entitySnapshot> used during move
let resizeAnchor = null;
let resizeStartBounds = null;
let resizeStartEntity = null;
let rubberBandRect = null; // { x, y, w, h } while rubber-banding

// Copy/paste state
let clipboard = null; // array of entity snapshots
let pasteOffset = 0;

// Undo/redo state
const undoStack = [];
const redoStack = [];
const MAX_HISTORY = 100;

// View transform state (pan + zoom)
let viewOffset = { x: 0, y: 0 };
let viewScale = 1.0;
let isPanning = false;
let panStart = { x: 0, y: 0 };
let panStartOffset = { x: 0, y: 0 };
let spaceDown = false;
// Device pixel ratio — kept in sync with the display in resize()
let dpr = window.devicePixelRatio || 1;

const HANDLE_SIZE = 8;
const HIT_TOLERANCE = 6;
const MIN_SIZE = 10;

// --- View helpers ---
function screenToWorld(sx, sy) {
  return { x: (sx - viewOffset.x) / viewScale, y: (sy - viewOffset.y) / viewScale };
}
function worldToScreen(wx, wy) {
  return { x: wx * viewScale + viewOffset.x, y: wy * viewScale + viewOffset.y };
}
function updateZoomDisplay() {
  zoomLevelBtn.textContent = Math.round(viewScale * 100) + "%";
}
function updateCursor() {
  if (spaceDown || isPanning) {
    canvas.classList.toggle("panning", !isPanning);
    canvas.classList.toggle("panning-active", isPanning);
    canvas.style.cursor = "";
  } else {
    canvas.classList.remove("panning", "panning-active");
    canvas.style.cursor = currentTool === "select" ? "default" : currentTool === "text" ? "text" : "crosshair";
  }
}
function applyZoom(factor, pivotX, pivotY) {
  // pivot in screen coordinates — keep that world point fixed under the cursor
  const wx = (pivotX - viewOffset.x) / viewScale;
  const wy = (pivotY - viewOffset.y) / viewScale;
  viewScale = Math.max(0.05, Math.min(20, viewScale * factor));
  viewOffset.x = pivotX - wx * viewScale;
  viewOffset.y = pivotY - wy * viewScale;
  updateZoomDisplay();
  redrawAll();
}
function resetView() {
  viewOffset = { x: 0, y: 0 };
  viewScale = 1.0;
  updateZoomDisplay();
  redrawAll();
}

// --- Tool switching ---
colorPicker.addEventListener("input", e => { currentColor = e.target.value; });
widthSlider.addEventListener("input", e => { currentWidth = parseInt(e.target.value, 10); });

function setTool(tool) {
  currentTool = tool;
  if (tool !== "select") { selectedIds.clear(); redrawAll(); }
  document.querySelectorAll(".tool-btn").forEach(btn => {
    btn.classList.toggle("active", btn.dataset.tool === tool);
  });
  updateCursor();
}

document.querySelectorAll(".tool-btn").forEach(btn => {
  btn.addEventListener("click", () => setTool(btn.dataset.tool));
});

// --- Entity bounding box ---
function getEntityBounds(e) {
  if (e.type === "line" || e.type === "arrow") {
    const x = Math.min(e.x1, e.x2), y = Math.min(e.y1, e.y2);
    return { x, y, w: Math.abs(e.x2 - e.x1) || 4, h: Math.abs(e.y2 - e.y1) || 4 };
  }
  return { x: e.x, y: e.y, w: e.width || 4, h: e.height || 4 };
}

function getCorners(b) {
  return [
    { x: b.x, y: b.y },             // nw
    { x: b.x + b.w, y: b.y },       // ne
    { x: b.x + b.w, y: b.y + b.h }, // se
    { x: b.x, y: b.y + b.h },       // sw
  ];
}

// --- Drawing functions ---
function drawStrokeEntity(e) {
  if (!e.points || e.points.length < 2) return;
  ctx.strokeStyle = e.color;
  ctx.lineWidth = e.strokeWidth;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  ctx.moveTo(e.x + e.points[0].x, e.y + e.points[0].y);
  for (let i = 1; i < e.points.length; i++) {
    ctx.lineTo(e.x + e.points[i].x, e.y + e.points[i].y);
  }
  ctx.stroke();
}

function drawRectEntity(e) {
  ctx.strokeStyle = e.color;
  ctx.lineWidth = e.strokeWidth;
  ctx.lineJoin = "miter";
  if (e.filled) {
    ctx.fillStyle = e.color;
    ctx.globalAlpha = 0.2;
    ctx.fillRect(e.x, e.y, e.width, e.height);
    ctx.globalAlpha = 1;
  }
  ctx.strokeRect(e.x, e.y, e.width, e.height);
}

function drawLineEntity(e) {
  ctx.strokeStyle = e.color;
  ctx.lineWidth = e.strokeWidth;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(e.x1, e.y1);
  ctx.lineTo(e.x2, e.y2);
  ctx.stroke();
}

function drawArrowEntity(e) {
  ctx.strokeStyle = e.color;
  ctx.lineWidth = e.strokeWidth;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  // Shaft
  ctx.beginPath();
  ctx.moveTo(e.x1, e.y1);
  ctx.lineTo(e.x2, e.y2);
  ctx.stroke();
  // Arrowhead
  const angle = Math.atan2(e.y2 - e.y1, e.x2 - e.x1);
  const headLen = Math.max(12, e.strokeWidth * 5);
  const headAngle = Math.PI / 6;
  ctx.beginPath();
  ctx.moveTo(e.x2, e.y2);
  ctx.lineTo(
    e.x2 - headLen * Math.cos(angle - headAngle),
    e.y2 - headLen * Math.sin(angle - headAngle)
  );
  ctx.moveTo(e.x2, e.y2);
  ctx.lineTo(
    e.x2 - headLen * Math.cos(angle + headAngle),
    e.y2 - headLen * Math.sin(angle + headAngle)
  );
  ctx.stroke();
}

function drawEllipseEntity(e) {
  const cx = e.x + e.width / 2;
  const cy = e.y + e.height / 2;
  const rx = Math.abs(e.width / 2);
  const ry = Math.abs(e.height / 2);
  if (rx < 0.5 || ry < 0.5) return;
  ctx.strokeStyle = e.color;
  ctx.lineWidth = e.strokeWidth;
  if (e.filled) {
    ctx.fillStyle = e.color;
    ctx.globalAlpha = 0.2;
    ctx.beginPath();
    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  ctx.beginPath();
  ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
  ctx.stroke();
}

function drawTextEntity(e) {
  ctx.fillStyle = e.color;
  ctx.font = e.fontSize + "px sans-serif";
  ctx.textBaseline = "top";
  ctx.fillText(e.text, e.x, e.y);
}

function drawEntity(e) {
  switch (e.type) {
    case "stroke":   drawStrokeEntity(e); break;
    case "rect":     drawRectEntity(e); break;
    case "ellipse":  drawEllipseEntity(e); break;
    case "line":     drawLineEntity(e); break;
    case "arrow":    drawArrowEntity(e); break;
    case "text":     drawTextEntity(e); break;
  }
}

// showHandles = true only when exactly one entity is selected (resize corners)
// All pixel sizes are divided by viewScale so they stay constant on-screen regardless of zoom.
function drawSelectionBox(e, showHandles) {
  const b = getEntityBounds(e);
  const pad = 4 / viewScale;
  const hs  = HANDLE_SIZE / viewScale;
  const lw  = 1 / viewScale;
  const dash = 4 / viewScale;
  ctx.save();
  ctx.setLineDash([dash, dash]);
  ctx.strokeStyle = "#4fc3f7";
  ctx.lineWidth = lw;
  ctx.strokeRect(b.x - pad, b.y - pad, b.w + 2 * pad, b.h + 2 * pad);
  ctx.setLineDash([]);
  if (showHandles) {
    const corners = getCorners({ x: b.x - pad, y: b.y - pad, w: b.w + 2 * pad, h: b.h + 2 * pad });
    for (const c of corners) {
      ctx.fillStyle = "#ffffff";
      ctx.strokeStyle = "#4fc3f7";
      ctx.lineWidth = lw;
      ctx.fillRect(c.x - hs / 2, c.y - hs / 2, hs, hs);
      ctx.strokeRect(c.x - hs / 2, c.y - hs / 2, hs, hs);
    }
  }
  ctx.restore();
}

function redrawAll() {
  // Reset to true identity first so clearRect covers the full physical canvas.
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // Bake DPR into the view transform so world-space coordinates map directly
  // to physical pixels — entities are re-rendered as sharp vectors every frame.
  ctx.save();
  ctx.setTransform(viewScale * dpr, 0, 0, viewScale * dpr, viewOffset.x * dpr, viewOffset.y * dpr);

  for (const e of entities.values()) {
    drawEntity(e);
  }
  if (previewEntity) {
    drawEntity(previewEntity);
  }
  // Draw selection outlines (resize handles only for single-selection)
  const showHandles = selectedIds.size === 1;
  for (const id of selectedIds) {
    if (entities.has(id)) {
      drawSelectionBox(entities.get(id), showHandles);
    }
  }
  // Draw rubber-band selection rectangle (world coords, scale-compensated line)
  if (rubberBandRect) {
    const lw = 1 / viewScale, dash = 4 / viewScale;
    ctx.save();
    ctx.setLineDash([dash, dash]);
    ctx.strokeStyle = "#4fc3f7";
    ctx.lineWidth = lw;
    ctx.strokeRect(rubberBandRect.x, rubberBandRect.y, rubberBandRect.w, rubberBandRect.h);
    ctx.fillStyle = "rgba(79, 195, 247, 0.05)";
    ctx.fillRect(rubberBandRect.x, rubberBandRect.y, rubberBandRect.w, rubberBandRect.h);
    ctx.setLineDash([]);
    ctx.restore();
  }

  ctx.restore(); // restore identity transform
}

// --- Canvas resize ---
function resize() {
  // Size the canvas backing store at physical pixels so it stays crisp on
  // HiDPI / Retina screens.  CSS keeps the element at 100% of the viewport.
  dpr = window.devicePixelRatio || 1;
  canvas.width  = Math.round(window.innerWidth  * dpr);
  canvas.height = Math.round(window.innerHeight * dpr);
  redrawAll();
}
window.addEventListener("resize", resize);
resize();

// --- Hit testing ---
function distToSegment(px, py, ax, ay, bx, by) {
  const dx = bx - ax, dy = by - ay;
  const lenSq = dx * dx + dy * dy;
  if (lenSq === 0) return Math.hypot(px - ax, py - ay);
  let t = ((px - ax) * dx + (py - ay) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  return Math.hypot(px - (ax + t * dx), py - (ay + t * dy));
}

function isPointInEntity(px, py, e) {
  // px/py are in world space; HIT_TOLERANCE is in screen pixels, so convert
  const tol = HIT_TOLERANCE / viewScale;
  switch (e.type) {
    case "stroke": {
      if (!e.points || e.points.length < 2) return false;
      for (let i = 1; i < e.points.length; i++) {
        const d = distToSegment(px, py,
          e.x + e.points[i - 1].x, e.y + e.points[i - 1].y,
          e.x + e.points[i].x, e.y + e.points[i].y);
        if (d < tol) return true;
      }
      return false;
    }
    case "rect":
      return px >= e.x && px <= e.x + e.width && py >= e.y && py <= e.y + e.height;
    case "ellipse": {
      const cx = e.x + e.width / 2, cy = e.y + e.height / 2;
      const rx = e.width / 2, ry = e.height / 2;
      if (rx < 0.5 || ry < 0.5) return false;
      const normTol = tol / Math.min(rx, ry);
      const d = Math.sqrt(((px - cx) / rx) ** 2 + ((py - cy) / ry) ** 2);
      return d <= 1 + normTol;
    }
    case "line":
    case "arrow":
      return distToSegment(px, py, e.x1, e.y1, e.x2, e.y2) < tol;
    case "text": {
      const b = getEntityBounds(e);
      return px >= b.x && px <= b.x + b.w && py >= b.y && py <= b.y + b.h;
    }
  }
  return false;
}

function hitTest(px, py) {
  const arr = Array.from(entities.values()).reverse();
  for (const e of arr) {
    if (isPointInEntity(px, py, e)) return e.id;
  }
  return null;
}

function hitTestHandle(px, py, e) {
  // px/py in world space; handle size and padding are in screen pixels → convert
  const pad = 4 / viewScale;
  const hs  = HANDLE_SIZE / viewScale;
  const b = getEntityBounds(e);
  const expanded = { x: b.x - pad, y: b.y - pad, w: b.w + 2 * pad, h: b.h + 2 * pad };
  const corners = getCorners(expanded);
  const labels = ["resize-nw", "resize-ne", "resize-se", "resize-sw"];
  for (let i = 0; i < corners.length; i++) {
    if (Math.abs(px - corners[i].x) < hs && Math.abs(py - corners[i].y) < hs) {
      return labels[i];
    }
  }
  return null;
}

// Returns ids of all entities whose bounding box overlaps the given rect
function entitiesInRect(rx, ry, rw, rh) {
  const x1 = rx, y1 = ry, x2 = rx + rw, y2 = ry + rh;
  const result = [];
  for (const e of entities.values()) {
    const b = getEntityBounds(e);
    if (b.x < x2 && b.x + b.w > x1 && b.y < y2 && b.y + b.h > y1) {
      result.push(e.id);
    }
  }
  return result;
}

// --- Undo / Redo ---
function updateUndoRedoBtns() {
  document.getElementById("undoBtn").disabled = undoStack.length === 0;
  document.getElementById("redoBtn").disabled = redoStack.length === 0;
}

function pushUndo(cmd) {
  undoStack.push(cmd);
  if (undoStack.length > MAX_HISTORY) undoStack.shift();
  redoStack.length = 0;
  updateUndoRedoBtns();
}

// cmd.type: "add" | "delete" | "update" | "clear"
//   add:    { entities: [...snapshots] }  – undo=delete, redo=add
//   delete: { entities: [...snapshots] }  – undo=add,    redo=delete
//   update: { changes: [{id, before, after}] }
//   clear:  { entities: [...snapshots] }  – undo=restore, redo=clear
function executeCommand(cmd, reverse) {
  switch (cmd.type) {
    case "add": {
      if (reverse) {
        for (const ent of cmd.entities) {
          entities.delete(ent.id);
          selectedIds.delete(ent.id);
          vscode.postMessage({ type: "entityDelete", payload: { id: ent.id } });
        }
      } else {
        for (const ent of cmd.entities) {
          entities.set(ent.id, JSON.parse(JSON.stringify(ent)));
          vscode.postMessage({ type: "entityAdd", payload: { entity: ent } });
        }
      }
      break;
    }
    case "delete": {
      if (reverse) {
        for (const ent of cmd.entities) {
          entities.set(ent.id, JSON.parse(JSON.stringify(ent)));
          vscode.postMessage({ type: "entityAdd", payload: { entity: ent } });
        }
      } else {
        for (const ent of cmd.entities) {
          entities.delete(ent.id);
          selectedIds.delete(ent.id);
          vscode.postMessage({ type: "entityDelete", payload: { id: ent.id } });
        }
      }
      break;
    }
    case "update": {
      for (const { id, before, after } of cmd.changes) {
        const ent = entities.get(id);
        if (!ent) continue;
        const patch = reverse ? before : after;
        Object.assign(ent, patch);
        vscode.postMessage({ type: "entityUpdate", payload: { id, changes: patch } });
      }
      break;
    }
    case "clear": {
      if (reverse) {
        for (const ent of cmd.entities) {
          entities.set(ent.id, JSON.parse(JSON.stringify(ent)));
          vscode.postMessage({ type: "entityAdd", payload: { entity: ent } });
        }
      } else {
        entities.clear();
        selectedIds.clear();
        vscode.postMessage({ type: "clear" });
      }
      break;
    }
  }
  redrawAll();
}

function applyUndo() {
  if (undoStack.length === 0) return;
  const cmd = undoStack.pop();
  executeCommand(cmd, true);
  redoStack.push(cmd);
  updateUndoRedoBtns();
}

function applyRedo() {
  if (redoStack.length === 0) return;
  const cmd = redoStack.pop();
  executeCommand(cmd, false);
  undoStack.push(cmd);
  updateUndoRedoBtns();
}

// --- Measure text for bounding box ---
function measureText(text, fontSize) {
  ctx.font = fontSize + "px sans-serif";
  const m = ctx.measureText(text);
  return { w: m.width, h: fontSize * 1.2 };
}

// --- Inline text input (prompt() is blocked in sandboxed webviews) ---
const textInputEl = document.getElementById("textInput");
let textInputCallback = null;
let textInputReady = false;

function showTextInput(x, y, defaultValue, fontSize, color, callback) {
  textInputEl.style.left = x + "px";
  textInputEl.style.top = y + "px";
  textInputEl.style.font = fontSize + "px sans-serif";
  textInputEl.style.color = color;
  textInputEl.style.display = "block";
  textInputEl.value = defaultValue;
  textInputCallback = callback;
  textInputReady = false;
  // Delay focus so the pointerdown event fully completes first,
  // preventing an immediate blur from hiding the input.
  setTimeout(() => {
    textInputEl.focus();
    textInputEl.select();
    textInputReady = true;
  }, 10);
}

function commitTextInput() {
  if (!textInputCallback) return;
  const val = textInputEl.value.trim();
  textInputEl.style.display = "none";
  const cb = textInputCallback;
  textInputCallback = null;
  cb(val || null);
}

function cancelTextInput() {
  textInputEl.style.display = "none";
  textInputCallback = null;
}

textInputEl.addEventListener("keydown", e => {
  if (e.key === "Enter") { e.preventDefault(); commitTextInput(); }
  if (e.key === "Escape") { e.preventDefault(); cancelTextInput(); }
  e.stopPropagation(); // prevent tool shortcuts while typing
});

textInputEl.addEventListener("blur", () => { if (textInputReady) commitTextInput(); });

// --- Pointer events ---
canvas.addEventListener("pointerdown", e => {
  // Middle mouse button or Space+left = pan
  if (e.button === 1 || (e.button === 0 && spaceDown)) {
    isPanning = true;
    panStart = { x: e.clientX, y: e.clientY };
    panStartOffset = { ...viewOffset };
    canvas.setPointerCapture(e.pointerId);
    updateCursor();
    e.preventDefault();
    return;
  }

  // Convert screen → world for all drawing/selection operations
  const { x: px, y: py } = screenToWorld(e.offsetX, e.offsetY);
  if (currentTool !== "text") {
    canvas.setPointerCapture(e.pointerId);
  }

  if (currentTool === "select") {
    // 1. Resize handle - only when exactly one entity is selected
    if (selectedIds.size === 1) {
      const singleId = [...selectedIds][0];
      const singleEnt = entities.get(singleId);
      if (singleEnt) {
        const handle = hitTestHandle(px, py, singleEnt);
        if (handle) {
          isDragging = true;
          dragMode = handle;
          resizeStartBounds = getEntityBounds(singleEnt);
          resizeStartEntity = JSON.parse(JSON.stringify(singleEnt));
          const cornerIdx = ["resize-nw", "resize-ne", "resize-se", "resize-sw"].indexOf(handle);
          const oppositeIdx = (cornerIdx + 2) % 4;
          resizeAnchor = getCorners(resizeStartBounds)[oppositeIdx];
          return;
        }
      }
    }

    // 2. Hit-test entities
    const hitId = hitTest(px, py);
    if (hitId) {
      if (e.shiftKey) {
        // Shift-click: toggle entity in/out of selection, no drag
        if (selectedIds.has(hitId)) {
          selectedIds.delete(hitId);
        } else {
          selectedIds.add(hitId);
        }
        redrawAll();
      } else {
        // Plain click: if not in selection replace it; then start moving all selected
        if (!selectedIds.has(hitId)) {
          selectedIds = new Set([hitId]);
        }
        isDragging = true;
        dragMode = "move";
        dragStart = { x: px, y: py };
        dragStartPositions = new Map();
        for (const id of selectedIds) {
          if (entities.has(id)) {
            dragStartPositions.set(id, JSON.parse(JSON.stringify(entities.get(id))));
          }
        }
        redrawAll();
      }
    } else {
      // Click on empty canvas
      if (!e.shiftKey) { selectedIds.clear(); }
      // Start rubber-band selection
      isDragging = true;
      dragMode = "rubber-band";
      dragStart = { x: px, y: py };
      rubberBandRect = { x: px, y: py, w: 0, h: 0 };
      redrawAll();
    }
    return;
  }

  isDragging = true;
  dragStart = { x: px, y: py };

  if (currentTool === "pen") {
    currentPoints = [{ x: px, y: py }];
  } else if (currentTool === "text") {
    isDragging = false;
    const sp = worldToScreen(px, py);
    showTextInput(sp.x, sp.y, "", 16 * viewScale, currentColor, text => {
      if (!text) return;
      const m = measureText(text, 16);
      const entity = {
        id: crypto.randomUUID(),
        type: "text",
        x: px, y: py,
        width: m.w, height: m.h,
        color: currentColor,
        createdBy: "",
        text: text,
        fontSize: 16,
      };
      entities.set(entity.id, entity);
      pushUndo({ type: "add", entities: [JSON.parse(JSON.stringify(entity))] });
      vscode.postMessage({ type: "entityAdd", payload: { entity } });
      redrawAll();
    });
  }
});

canvas.addEventListener("pointermove", e => {
  if (isPanning) {
    viewOffset.x = panStartOffset.x + (e.clientX - panStart.x);
    viewOffset.y = panStartOffset.y + (e.clientY - panStart.y);
    updateZoomDisplay();
    redrawAll();
    return;
  }
  if (!isDragging) return;
  const { x: px, y: py } = screenToWorld(e.offsetX, e.offsetY);

  if (currentTool === "select") {
    if (dragMode === "move") {
      const dx = px - dragStart.x;
      const dy = py - dragStart.y;
      for (const [id, orig] of dragStartPositions) {
        const ent = entities.get(id);
        if (!ent) continue;
        if (ent.type === "line" || ent.type === "arrow") {
          ent.x1 = orig.x1 + dx; ent.y1 = orig.y1 + dy;
          ent.x2 = orig.x2 + dx; ent.y2 = orig.y2 + dy;
          ent.x = Math.min(ent.x1, ent.x2);
          ent.y = Math.min(ent.y1, ent.y2);
        } else {
          ent.x = orig.x + dx;
          ent.y = orig.y + dy;
        }
      }
      redrawAll();
    } else if (dragMode === "rubber-band") {
      rubberBandRect = {
        x: Math.min(dragStart.x, px),
        y: Math.min(dragStart.y, py),
        w: Math.abs(px - dragStart.x),
        h: Math.abs(py - dragStart.y),
      };
      redrawAll();
    } else if (dragMode && dragMode.startsWith("resize-")) {
      const singleId = [...selectedIds][0];
      if (!singleId) return;
      const ent = entities.get(singleId);
      if (!ent) return;
      const anchor = resizeAnchor;
      const newX = Math.min(anchor.x, px);
      const newY = Math.min(anchor.y, py);
      const newW = Math.max(MIN_SIZE, Math.abs(px - anchor.x));
      const newH = Math.max(MIN_SIZE, Math.abs(py - anchor.y));

      if (ent.type === "stroke") {
        const oldB = resizeStartBounds;
        const scaleX = oldB.w > 0 ? newW / oldB.w : 1;
        const scaleY = oldB.h > 0 ? newH / oldB.h : 1;
        const orig = resizeStartEntity;
        ent.x = newX; ent.y = newY;
        ent.width = newW; ent.height = newH;
        ent.points = orig.points.map(p => ({ x: p.x * scaleX, y: p.y * scaleY }));
      } else if (ent.type === "line" || ent.type === "arrow") {
        const oldB = resizeStartBounds;
        const scaleX = oldB.w > 0 ? newW / oldB.w : 1;
        const scaleY = oldB.h > 0 ? newH / oldB.h : 1;
        const orig = resizeStartEntity;
        const origMinX = Math.min(orig.x1, orig.x2);
        const origMinY = Math.min(orig.y1, orig.y2);
        ent.x1 = newX + (orig.x1 - origMinX) * scaleX;
        ent.y1 = newY + (orig.y1 - origMinY) * scaleY;
        ent.x2 = newX + (orig.x2 - origMinX) * scaleX;
        ent.y2 = newY + (orig.y2 - origMinY) * scaleY;
        ent.x = newX; ent.y = newY;
        ent.width = newW; ent.height = newH;
      } else if (ent.type === "text") {
        const oldB = resizeStartBounds;
        const scaleY = oldB.h > 0 ? newH / oldB.h : 1;
        const orig = resizeStartEntity;
        ent.fontSize = Math.max(8, orig.fontSize * scaleY);
        ent.x = newX; ent.y = newY;
        const m = measureText(ent.text, ent.fontSize);
        ent.width = m.w; ent.height = m.h;
      } else {
        ent.x = newX; ent.y = newY;
        ent.width = newW; ent.height = newH;
      }
      redrawAll();
    }
    return;
  }

  if (currentTool === "pen") {
    const prev = currentPoints[currentPoints.length - 1];
    const pt = { x: px, y: py };
    currentPoints.push(pt);
    // Draw directly in device-pixel space (ctx is at identity outside redrawAll).
    // worldToScreen gives CSS pixels; multiply by dpr to get device pixels.
    const prevS = worldToScreen(prev.x, prev.y);
    const ptS   = worldToScreen(pt.x, pt.y);
    ctx.strokeStyle = currentColor;
    ctx.lineWidth = currentWidth * viewScale * dpr;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(prevS.x * dpr, prevS.y * dpr);
    ctx.lineTo(ptS.x  * dpr, ptS.y  * dpr);
    ctx.stroke();
    return;
  }

  if (currentTool === "rect") {
    const x = Math.min(dragStart.x, px), y = Math.min(dragStart.y, py);
    const w = Math.abs(px - dragStart.x), h = Math.abs(py - dragStart.y);
    previewEntity = {
      type: "rect", x, y, width: w, height: h,
      color: currentColor, strokeWidth: currentWidth, filled: false,
    };
    redrawAll();
    return;
  }

  if (currentTool === "ellipse") {
    const x = Math.min(dragStart.x, px), y = Math.min(dragStart.y, py);
    const w = Math.abs(px - dragStart.x), h = Math.abs(py - dragStart.y);
    previewEntity = {
      type: "ellipse", x, y, width: w, height: h,
      color: currentColor, strokeWidth: currentWidth, filled: false,
    };
    redrawAll();
    return;
  }

  if (currentTool === "line") {
    previewEntity = {
      type: "line",
      x1: dragStart.x, y1: dragStart.y, x2: px, y2: py,
      x: Math.min(dragStart.x, px), y: Math.min(dragStart.y, py),
      width: Math.abs(px - dragStart.x), height: Math.abs(py - dragStart.y),
      color: currentColor, strokeWidth: currentWidth,
    };
    redrawAll();
    return;
  }

  if (currentTool === "arrow") {
    previewEntity = {
      type: "arrow",
      x1: dragStart.x, y1: dragStart.y, x2: px, y2: py,
      x: Math.min(dragStart.x, px), y: Math.min(dragStart.y, py),
      width: Math.abs(px - dragStart.x), height: Math.abs(py - dragStart.y),
      color: currentColor, strokeWidth: currentWidth,
    };
    redrawAll();
    return;
  }
});

function buildChanges(ent) {
  if (ent.type === "line" || ent.type === "arrow") {
    return { x: ent.x, y: ent.y, width: ent.width, height: ent.height, x1: ent.x1, y1: ent.y1, x2: ent.x2, y2: ent.y2 };
  } else if (ent.type === "stroke") {
    return { x: ent.x, y: ent.y, width: ent.width, height: ent.height, points: ent.points };
  } else if (ent.type === "text") {
    return { x: ent.x, y: ent.y, width: ent.width, height: ent.height, fontSize: ent.fontSize };
  }
  return { x: ent.x, y: ent.y, width: ent.width, height: ent.height };
}

function finishDrag(e) {
  if (!isDragging) return;
  isDragging = false;
  const { x: px, y: py } = screenToWorld(e.offsetX, e.offsetY);

  if (currentTool === "select") {
    if (dragMode === "move") {
      // Build undo from start-snapshots vs. current state
      const undoChanges = [];
      for (const [id, orig] of dragStartPositions) {
        const ent = entities.get(id);
        if (!ent) continue;
        const before = buildChanges(orig);
        const after = buildChanges(ent);
        undoChanges.push({ id, before, after });
      }
      const actuallyMoved = undoChanges.some(c => JSON.stringify(c.before) !== JSON.stringify(c.after));
      if (actuallyMoved) pushUndo({ type: "update", changes: undoChanges });
      for (const { id, after } of undoChanges) {
        vscode.postMessage({ type: "entityUpdate", payload: { id, changes: after } });
      }
    } else if (dragMode && dragMode.startsWith("resize-")) {
      const singleId = [...selectedIds][0];
      if (singleId && entities.has(singleId)) {
        const ent = entities.get(singleId);
        const before = buildChanges(resizeStartEntity);
        const after = buildChanges(ent);
        if (JSON.stringify(before) !== JSON.stringify(after)) {
          pushUndo({ type: "update", changes: [{ id: singleId, before, after }] });
        }
        vscode.postMessage({ type: "entityUpdate", payload: { id: singleId, changes: after } });
      }
    } else if (dragMode === "rubber-band") {
      if (rubberBandRect && rubberBandRect.w > 2 && rubberBandRect.h > 2) {
        const ids = entitiesInRect(rubberBandRect.x, rubberBandRect.y, rubberBandRect.w, rubberBandRect.h);
        if (e.shiftKey) {
          for (const id of ids) selectedIds.add(id);
        } else {
          selectedIds = new Set(ids);
        }
      }
      rubberBandRect = null;
    }
    dragMode = null;
    dragStartPositions = null;
    resizeAnchor = null;
    resizeStartBounds = null;
    resizeStartEntity = null;
    redrawAll();
    return;
  }

  if (currentTool === "pen") {
    previewEntity = null;
    if (currentPoints.length < 2) { currentPoints = []; return; }
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const p of currentPoints) {
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    const relPoints = currentPoints.map(p => ({ x: p.x - minX, y: p.y - minY }));
    const entity = {
      id: crypto.randomUUID(),
      type: "stroke",
      x: minX, y: minY,
      width: maxX - minX, height: maxY - minY,
      color: currentColor,
      createdBy: "",
      points: relPoints,
      strokeWidth: currentWidth,
    };
    entities.set(entity.id, entity);
    pushUndo({ type: "add", entities: [JSON.parse(JSON.stringify(entity))] });
    vscode.postMessage({ type: "entityAdd", payload: { entity } });
    currentPoints = [];
    redrawAll();
    return;
  }

  if (currentTool === "rect") {
    previewEntity = null;
    const x = Math.min(dragStart.x, px), y = Math.min(dragStart.y, py);
    const w = Math.abs(px - dragStart.x), h = Math.abs(py - dragStart.y);
    if (w < 3 && h < 3) { redrawAll(); return; }
    const entity = {
      id: crypto.randomUUID(),
      type: "rect",
      x, y, width: w, height: h,
      color: currentColor,
      createdBy: "",
      strokeWidth: currentWidth,
      filled: false,
    };
    entities.set(entity.id, entity);
    pushUndo({ type: "add", entities: [JSON.parse(JSON.stringify(entity))] });
    vscode.postMessage({ type: "entityAdd", payload: { entity } });
    redrawAll();
    return;
  }

  if (currentTool === "ellipse") {
    previewEntity = null;
    const x = Math.min(dragStart.x, px), y = Math.min(dragStart.y, py);
    const w = Math.abs(px - dragStart.x), h = Math.abs(py - dragStart.y);
    if (w < 3 && h < 3) { redrawAll(); return; }
    const entity = {
      id: crypto.randomUUID(),
      type: "ellipse",
      x, y, width: w, height: h,
      color: currentColor,
      createdBy: "",
      strokeWidth: currentWidth,
      filled: false,
    };
    entities.set(entity.id, entity);
    pushUndo({ type: "add", entities: [JSON.parse(JSON.stringify(entity))] });
    vscode.postMessage({ type: "entityAdd", payload: { entity } });
    redrawAll();
    return;
  }

  if (currentTool === "line") {
    previewEntity = null;
    const dx = px - dragStart.x, dy = py - dragStart.y;
    if (Math.hypot(dx, dy) < 3) { redrawAll(); return; }
    const entity = {
      id: crypto.randomUUID(),
      type: "line",
      x: Math.min(dragStart.x, px), y: Math.min(dragStart.y, py),
      width: Math.abs(dx), height: Math.abs(dy),
      x1: dragStart.x, y1: dragStart.y, x2: px, y2: py,
      color: currentColor,
      createdBy: "",
      strokeWidth: currentWidth,
    };
    entities.set(entity.id, entity);
    pushUndo({ type: "add", entities: [JSON.parse(JSON.stringify(entity))] });
    vscode.postMessage({ type: "entityAdd", payload: { entity } });
    redrawAll();
    return;
  }

  if (currentTool === "arrow") {
    previewEntity = null;
    const dx = px - dragStart.x, dy = py - dragStart.y;
    if (Math.hypot(dx, dy) < 3) { redrawAll(); return; }
    const entity = {
      id: crypto.randomUUID(),
      type: "arrow",
      x: Math.min(dragStart.x, px), y: Math.min(dragStart.y, py),
      width: Math.abs(dx), height: Math.abs(dy),
      x1: dragStart.x, y1: dragStart.y, x2: px, y2: py,
      color: currentColor,
      createdBy: "",
      strokeWidth: currentWidth,
    };
    entities.set(entity.id, entity);
    pushUndo({ type: "add", entities: [JSON.parse(JSON.stringify(entity))] });
    vscode.postMessage({ type: "entityAdd", payload: { entity } });
    redrawAll();
    return;
  }
}

function handlePointerUp(e) {
  if (isPanning) {
    isPanning = false;
    updateCursor();
    return;
  }
  finishDrag(e);
}
canvas.addEventListener("pointerup", handlePointerUp);
canvas.addEventListener("pointercancel", handlePointerUp);

// --- Double-click to edit text ---
canvas.addEventListener("dblclick", e => {
  const { x: px, y: py } = screenToWorld(e.offsetX, e.offsetY);
  const hitId = hitTest(px, py);
  if (hitId) {
    const ent = entities.get(hitId);
    if (ent && ent.type === "text") {
      const beforeText = ent.text, beforeW = ent.width, beforeH = ent.height;
      const sp = worldToScreen(ent.x, ent.y);
      showTextInput(sp.x, sp.y, ent.text, ent.fontSize * viewScale, ent.color, newText => {
        if (!newText) return;
        ent.text = newText;
        const m = measureText(newText, ent.fontSize);
        ent.width = m.w;
        ent.height = m.h;
        if (newText !== beforeText) {
          pushUndo({ type: "update", changes: [{ id: hitId,
            before: { text: beforeText, width: beforeW, height: beforeH },
            after:  { text: newText,   width: m.w,    height: m.h } }] });
        }
        vscode.postMessage({ type: "entityUpdate", payload: { id: hitId, changes: { text: newText, width: m.w, height: m.h } } });
        redrawAll();
      });
    }
  }
});

// --- Zoom / pan (mouse wheel) ---
// Ctrl+scroll (or trackpad pinch) → zoom centred on cursor
// Plain scroll                    → pan (matches Figma / Excalidraw behaviour)
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  if (e.ctrlKey || e.metaKey) {
    applyZoom(e.deltaY < 0 ? 1.1 : 1 / 1.1, e.offsetX, e.offsetY);
  } else {
    viewOffset.x -= e.deltaX;
    viewOffset.y -= e.deltaY;
    updateZoomDisplay();
    redrawAll();
  }
}, { passive: false });

// --- Zoom buttons ---
document.getElementById("zoomInBtn").addEventListener("click", () => {
  applyZoom(1.25, window.innerWidth / 2, window.innerHeight / 2);
});
document.getElementById("zoomOutBtn").addEventListener("click", () => {
  applyZoom(1 / 1.25, window.innerWidth / 2, window.innerHeight / 2);
});
zoomLevelBtn.addEventListener("click", resetView);

// --- Space key pan mode ---
document.addEventListener("keydown", ev => {
  if (ev.code === "Space" && (ev.target === document.body || ev.target === canvas)) {
    if (!spaceDown) { spaceDown = true; updateCursor(); }
    ev.preventDefault();
  }
}, true); // capture phase so it fires before other keydown handlers
document.addEventListener("keyup", ev => {
  if (ev.code === "Space") { spaceDown = false; updateCursor(); }
});

// --- Delete / Clear ---
document.getElementById("deleteBtn").addEventListener("click", () => {
  const snapshot = [...selectedIds].map(id => entities.get(id)).filter(Boolean)
    .map(ent => JSON.parse(JSON.stringify(ent)));
  if (snapshot.length === 0) return;
  pushUndo({ type: "delete", entities: snapshot });
  for (const id of [...selectedIds]) {
    entities.delete(id);
    vscode.postMessage({ type: "entityDelete", payload: { id } });
  }
  selectedIds.clear();
  redrawAll();
});

document.getElementById("clearBtn").addEventListener("click", () => {
  const snapshot = [...entities.values()].map(ent => JSON.parse(JSON.stringify(ent)));
  if (snapshot.length > 0) pushUndo({ type: "clear", entities: snapshot });
  entities.clear();
  selectedIds.clear();
  vscode.postMessage({ type: "clear" });
  redrawAll();
});

document.getElementById("undoBtn").addEventListener("click", applyUndo);
document.getElementById("redoBtn").addEventListener("click", applyRedo);
document.getElementById("saveBtn").addEventListener("click", savePng);

function savePng() {
  // Temporarily deselect so selection boxes are not included in the export
  const savedIds = new Set(selectedIds);
  selectedIds.clear();
  redrawAll();

  const offCanvas = document.createElement("canvas");
  offCanvas.width = canvas.width;
  offCanvas.height = canvas.height;
  const offCtx = offCanvas.getContext("2d");
  offCtx.fillStyle = getComputedStyle(document.body).backgroundColor || "#1e1e1e";
  offCtx.fillRect(0, 0, offCanvas.width, offCanvas.height);
  offCtx.drawImage(canvas, 0, 0);

  const dataUrl = offCanvas.toDataURL("image/png");

  selectedIds = savedIds;
  redrawAll();

  vscode.postMessage({ type: "savePng", payload: { dataUrl } });
}

// --- Keyboard shortcuts ---
document.addEventListener("keydown", e => {
  if (e.target !== document.body && e.target !== canvas) return;
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
    e.preventDefault();
    savePng();
    return;
  }
  if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === "z") {
    e.preventDefault();
    applyUndo();
    return;
  }
  if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === "y" || (e.shiftKey && e.key.toLowerCase() === "z"))) {
    e.preventDefault();
    applyRedo();
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "c") {
    e.preventDefault();
    if (selectedIds.size > 0) {
      clipboard = [...selectedIds]
        .map(id => entities.get(id))
        .filter(Boolean)
        .map(ent => JSON.parse(JSON.stringify(ent)));
      pasteOffset = 0;
    }
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "v") {
    e.preventDefault();
    if (!clipboard || clipboard.length === 0) return;
    pasteOffset += 16;
    const newIds = new Set();
    const pastedSnapshots = [];
    for (const orig of clipboard) {
      const pasted = JSON.parse(JSON.stringify(orig));
      pasted.id = crypto.randomUUID();
      if (pasted.type === "line" || pasted.type === "arrow") {
        pasted.x1 += pasteOffset; pasted.y1 += pasteOffset;
        pasted.x2 += pasteOffset; pasted.y2 += pasteOffset;
        pasted.x  += pasteOffset; pasted.y  += pasteOffset;
      } else {
        pasted.x += pasteOffset;
        pasted.y += pasteOffset;
      }
      entities.set(pasted.id, pasted);
      newIds.add(pasted.id);
      pastedSnapshots.push(JSON.parse(JSON.stringify(pasted)));
      vscode.postMessage({ type: "entityAdd", payload: { entity: pasted } });
    }
    pushUndo({ type: "add", entities: pastedSnapshots });
    selectedIds = newIds;
    setTool("select");
    redrawAll();
    return;
  }
  switch (e.key.toLowerCase()) {
    case "v": setTool("select"); break;
    case "p": setTool("pen"); break;
    case "r": setTool("rect"); break;
    case "c": setTool("ellipse"); break;
    case "l": setTool("line"); break;
    case "a": setTool("arrow"); break;
    case "t": setTool("text"); break;
  }
  if ((e.key === "Delete" || e.key === "Backspace") && selectedIds.size > 0) {
    const snapshot = [...selectedIds].map(id => entities.get(id)).filter(Boolean)
      .map(ent => JSON.parse(JSON.stringify(ent)));
    if (snapshot.length > 0) pushUndo({ type: "delete", entities: snapshot });
    for (const id of [...selectedIds]) {
      entities.delete(id);
      vscode.postMessage({ type: "entityDelete", payload: { id } });
    }
    selectedIds.clear();
    redrawAll();
  }
});

// --- Messages from extension ---
window.addEventListener("message", event => {
  const msg = event.data;
  switch (msg.type) {
    case "entityAdd":
      entities.set(msg.payload.entity.id, msg.payload.entity);
      redrawAll();
      break;
    case "entityUpdate": {
      const e = entities.get(msg.payload.id);
      if (e) {
        Object.assign(e, msg.payload.changes);
        redrawAll();
      }
      break;
    }
    case "entityDelete":
      entities.delete(msg.payload.id);
      selectedIds.delete(msg.payload.id);
      redrawAll();
      break;
    case "clear":
      entities.clear();
      selectedIds.clear();
      redrawAll();
      break;
    case "fullSync":
      entities.clear();
      for (const e of msg.payload.entities) {
        entities.set(e.id, e);
      }
      redrawAll();
      break;
  }
});

// Request full sync on load (handles webview re-creation)
vscode.postMessage({ type: "requestFullSync" });
</script>
</body>
</html>
